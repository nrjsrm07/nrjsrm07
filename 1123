n=int(input("Enter any value:"))
if 1<=n<=50:
    if (n%3==0 and n%5==0):
        print("Three Five")
    elif n%3==0:
        print("three")
    elif n%5==0:
        print("five")
    else:
        print("India")
else:
    print("Please enter number between 1 to 50")
a=[11,2,5,9,2,7,45,7]
b=[]
for i in range(len(a)):
    for j in range(i):
        if a[j]==a[i]:
            b.append(a[j])                
print(set(b)) 

Live Furnish interview question
l=[4,2,3,1,1,2,4,2,2,4]
d={}
for i in l:
    count=0
    for j in l:
        if i==j:
            count+=1
    d[i]=count
print(d)
what is function? types of function
oops- class object, polymorphism, inhertance, abstraction, encapsulation, constructor
variable scope
Abstract class and pure abstract class
Quntative apptitude
<h3>OOPS</h3>
<p> OOPS is a programing concept that works on the principle of Abstraction, Encapsulation, Inheritentance and Polymorphism. It allows user to create objects and re-use & manipulate them. <p>
<p> Class--> It is a blueprint of an object. It is only logical component and not the physical entity.<br> Implimentation--> <br>   class classname: <br>          ''' documentation string''' <br>        variables => properties/attributes <br>            methods=>actions/behaviors</p>
class Student:
    '''this class is developed for demo purpose'''
    #variables
    #methods
print(Student.__doc__)
class Student:
    '''This a another demo class'''
    def __init__(self):
        self.name="Neeraj"
        self.roll=101
    def talk(self):
        print("hello, my name is", self.name)
        print("hello, my roll number is", self.roll)
s1=Student()
print(s1.name)
print(s1.roll)
s1.talk()
class Student:
    '''This is another demo class ...'''
    def __init__(self,namee, rollno):
        self.name=namee
        self.roll=rollno
    def talk(self):
        print("hello, my name is", self.name)
        print("hello, my roll number is", self.roll)
s2=Student("Pankaj", 102)
s3=Student("Vanshu",103)
s2.talk()
print("*"*30)
s3.talk()
<h2>self</h2>
1)self is the reference variable pointing to current object. 2)self is not keyword. 3)self is the first argument. 4)self used within the class only. 5)not required to provide value to self while creating object, PVM will take care of that.<br> main <b>purpuse</b> of the self is to declare instance variables and to access instance variable values
class Test:
    def __init__(self):
        print("Address of object pointed by self : ", id(self))
t=Test()
print("Address of object pointed by t is : ", id(t))
class Test:
    '''This is demo class for self and constructor'''
    def __init__(self):
        print("constructor")
    def m1(self,x):
        print("x value is : ", x)
t=Test()
t.m1(10)

class Student:
    def __init__(self, namee, rollno, markss):
        self.name=namee
        self.marks=markss
        self.roll=rollno
    def talk(self):
        print("hello, my name is", self.name)
        print("my roll number is", self.roll)
        print("My marks are :", self.marks)
s=Student("Dhoni",101,90)
s1=Student("Kholi",102,88)
s2=Student("Ganguly", 103,75)
s.talk()
print("*"*30)
s1.talk()
print("*"*30)
s2.talk()
self is not a keyword, we can use any thing in place of self
class Student:
    def __init__(delf, namee, rollno, markss):
        delf.name=namee
        delf.marks=markss
        delf.roll=rollno
    def talk(kelf):
        print("hello, my name is", kelf.name)
        print("my roll number is", kelf.roll)
        print("My marks are :", kelf.marks)
s=Student("Toni",101,90)
s1=Student("Goli",102,88)
s2=Student("Gangu", 103,75)
s.talk()
print("*"*30)
s1.talk()
print("*"*30)
s2.talk()
class Student:
    def __init__(namee, rollno, markss):
        self.name=namee
        self.marks=markss
        self.roll=rollno
    def talk(kelf):
        print("hello, my name is", kelf.name)
        print("my roll number is", kelf.roll)
        print("My marks are :", kelf.marks)
s=Student("Toni",101,90)
s.talk()
<h2>Constructor</h2>
1. Constructor is a special method.<br>2. The name of the constructor is __init__().<br>3. it will be executed automatically.<br>4. per object constructor wil executed only once.<br> 5. atleast one argument(atleast self)<br>6. constructor is optional, default constructor will be provided by PVM.
class Test:
    def __init__(self):
        print("constructor execution...")
t=Test()
t1=Test()
t2=Test()
t3=Test()
class Student:
    def __init__(self, namee, rollno, markss):
        self.name=namee
        self.roll=rollno
        self.marks=markss
    def talk(kelf):
        print("hello, my name is", kelf.name)
        print("my roll number is", kelf.roll)
        print("My marks are :", kelf.marks)
s=Student("Dhoni",101,"90%")
s.talk()
class Student:
    def __init__(self, namee, rollno):
        print("creating instance variable and performing initilization...")
        self.name=namee
        self.roll=rollno
s=Student("Dhoni", 101)
print(s.name,s.roll)
s1=Student("Kohli",102)
print(s1.name,s2.roll)

class Test:
    def m1(self):
        print("method")
t=Test()
t.m1()
class Test:
    def __init__(self):
        print("constructor method")
t=Test()
t.__init__()
t.__init__()
t.__init__()
<b>overloading</b> is not possible for Constructor and methods in Python. The most recent constructor/method will be consider
class Test:
    def __init__(self):
        print("no arg constructor")
    def __init__(self,x):
        print("no arg constructor")
t=Test()
t1=Test(10)
    
class Test:
    def __init__(self):
        print("no arg constructor")
    def __init__(self,x):
        print("one arg constructor")
t1=Test(10)
class Movie:
    '''This is an example to explain OOPS'''
    def __init__(self, movie_name, movie_hero, movie_heroine):
        self.title=movie_name
        self.hero=movie_hero
        self.heroine=movie_heroine
    def info(self):
        print("Movie Name : ", self.title)
        print("Movie Hero : ", self.hero)
        print("Movie Heroine : ", self.heroine)
list_of_movies=[] 
while True:
    title=input("Enter movie name")
    hero=input("Enter Hero name")
    heroine=input("Enter Heroine name")
    m=Movie(title,hero,heroine)
    list_of_movies.append(m)
    print("movie added successfully")
    option=input("Do you want to add another movie[Yes/No]: ")
    if option.lower()=="no":
        break
print("All movies Information....")
for i in list_of_movies:
    i.info()
    print("*"*20)
class Test:
    def Test(self):
        print("it is some special method")
t=Test()
t.Test()
<h2>Types of variables</h2>
1. Instance Variable / Object Level <br>
2. Static Variable / Class Level<br>
3. Local Variable / Method Level
class Test:
    a=10 #static variable
    def __init__(self):
        self.b=20 #instance variable
        Test.c=30 #static variable
    def m1 (self):
        self.d=40#instance variable
    def m2 (self):
        Test.e=50#static variable
    def m3 (self):
        x=59 #local variable
        Test.f=x+1#static variable
t1=Test()
t1.m1()
t1.m2()
t1.m3()
print(Test.__dict__)
print(t1.__dict__)
print(t1.a)
print(t1.b)
print(t1.c)
print(t1.d)
print(t1.e)
print(t1.f)
<h2>Types of Methods</h2>
class Student:
    school_name="Little Angels School"
    def __init__(self,namee,rollno):
        self.name=namee # instance variable
        self.roll=rollno # instance variable
    def getStudentInfo(self): # instance method
        print("Student Name:", self.name)
        print("Student Roll No.:", self.roll)
    @classmethod
    def getSchoolInfo(cls): # class method
        print("School Name",cls.school_name)
    @staticmethod
    def getSum(a,b): # Static Method
        return a+b
s=Student("Dhoni",101)
s.getStudentInfo()
s.getSchoolInfo
print(s.getSum(2,9))
class Demo:
    a = 10 #Static Variable
    def __init__(self):
        self.b=20 #Instant Variable
        Demo.c=30 #Static variable
    def m1(self):
        self.d=40 #Instant Variable
    @classmethod
    def m2 (cls):
        cls.e=50 #Static Variable
        Demo.f=60 #Static Variable
    @staticmethod
    def m3 ():
        x=60
d=Demo()
d.m1()
print(d.__dict__)
d.m2()
d.g=70
print(Demo.__dict__)
print(d.__dict__)
class Demo:
    a = 10 #Static Variable
    def __init__(self):
        self.b=20 #Instant Variable
        Demo.c=30 #Static variable
    def display(self):
        print (Demo.a, self.b, self.c)
d=Demo()
d.display()
print(Demo.a,d.b,Demo.c)
<h2>Static Variable declaration </h2>
1. within the class directly but outside of method<br> 
2. inside class method by using <b>class name</b> or by <b>cls variable</b><br>
3. outside class by using  class Name <br>
4. Inside constructor by using  class Name <br>
5. Inside instance method by using  class Name<br>
6. inside static method by using class name

class Static_Variable:
    a=10
    def __init__(self):
        Static_Variable.b=20
        print(self.a, self.b)
        print(Static_Variable.a, Static_Variable.b)
    def m1(self):
        Static_Variable.c=30
        print(self.a, self.b)
        print(Static_Variable.a, Static_Variable.b)
    @classmethod
    def m2 (cls):
        Static_Variable.d=40
        cls.a=50
        print(cls.b, Static_Variable.a)
    @staticmethod
    def m3():
        Static_Variable.d=60
sv=Static_Variable()
sv.m1()
sv.m2()
sv.m3()
print (Static_Variable.d)
Static_Variable.g=70
print(Static_Variable.__dict__)    
class Test4:
    a=10
    @classmethod
    def m1(cls):
        return a
    @classmethod
    def m2(cls):
        del Test4.a
t4=Test4()
print(t4.m1())
t4.m2()
class Test:
    @staticmethod
    def avg(l1):
       res=sum(l1)/len(l1) # res is a local variable
       print("Average is : ", res)
t1=Test()
li=[10,20,30,40,50]
t1.avg(li)
class Customer:
    bankname="ICICI Bank"
    def __init__(self,name,balance=0.0):
        self.name=name
        self.balance=balance
    def deposit(self,amount):
        self.balance=self.balance+amount
        print("After depositing {} amount, your balance is {}".format(amount,self.balance))
    def withdraw(self,amount):
        if amount>self.balance:
            print ("Insufficient Balance")
        else:
            self.balance=self.balance-amount
            print("After withdrawing {} amount, your balance is {}".format(amount,self.balance))
print ("Welcome to ", Customer.bankname)
name=input("Enter your name : ")
c=Customer(name)
while True:
    print("d-deposit\n w-withdraw\n e-exit")
    option=input("Choose your option")
    if option.lower()=='d':
        amount=float(input("Enter amount to deposit : "))
        c.deposit(amount)
    elif option.lower()=='w':
        amount=float(input("Enter amount to withdraw : "))
        c.withdraw(amount)
    elif option.lower()=='e':
        print("Thanks for banking")
        break
    else:
        print("invalid option\nplease choose a valid ioption")
def find_max(nums):
    max_num = float("-inf") # smaller than all other numbers
    for num in nums:
        if num > max_num:
            max_num=num
    return max_num
<h2>Setter and Getter</h2>
class Student:
    def setName(self, name):
        self.name=name
    def getName(self):
        return self.name
    def setMarks(self,marks):
        self.marks=marks
    def getMarks(self):
        return self.marks
n=int(input("Enter numbers of students : "))
students=[]
for i in range(n):
    s=Student()
    name=input("Enter name : ")
    marks=int(input("Enter marks : "))
    s.setName(name)
    s.setMarks(marks)
    students.append(s)
for s in students:
    print("Hello {} !!\n your marks are {}".format(s.getName(),s.getMarks()))


class Bird:
    wings=2
    @classmethod 
    def fly(cls,name):
        print("{} flying with {} wings".format(name,cls.wings))
b=Bird()
b.fly("Eagle")
Bird.fly("parrot")
class Test:
    count=0
    def __init__(self):
        Test.count+=1
    @classmethod
    def getNoOfObjects(cls):
        print("Total number of objects are : ", cls.count)
Test.getNoOfObjects()
t1=Test()
t2=Test()
t2=Test()
Test.getNoOfObjects()
<h3>Static Method</h3>
class Maths:
    def add(a,b):
        print("The sum of {} and {} is {}".format(a,b,a+b))
    def product(a,b):
        print("The product of {} and {} is {}".format(a,b,a*b))
Maths.add(4,6)
Maths.product(4,6)
<h3>Instance Method vs Class Method vs Static Method</h3>
1. if we are using any instance variable inside method body then we should go for instance method. <br> We can call by using object reference only.<br><br>
2. if we are using only static variable inside method body then this method no way related to a paritcular object, we should declare such type of methods as classmethod. we can declare by using @classmethod decorator.<br> We can call either by using object reference or by using classname.<br><br>
3.if we are not using any instance variable and any static variable inside method body, we should go for static method. We can declare static method by using @staticmethod decorator.<br>we can call either by using object reference or by using class name.
using only instance variable--> instance method<br>
using only static variable --> class method<br>
using instance and static variable-->instance method<br>
using instance and local variable-->instance method<br>
using statice and local variable --> class method<br>
using only local variable --> static method
<h3><center>Inner Class</center></h3>
class Outer:
    def __init__(self):
        print("Outer object creation")
    class Inner:
        def __init__(self):
            print("Inner object creation")
        def m1(self):
            print("Inner class method")
        @staticmethod
        def m2():
            print("Static method")

o=Outer()
i=o.Inner()
i.m1()
Outer().Inner().m1()  
Outer.Inner().m1()
Outer().Inner.m2()

class Human:
    def __init__(self,namee):
        self.name=namee
        self.head=self.Head()
    def info(self):
        print ("Hello, my name is ", self.name)
        print("I am busy with")
        self.head.talk()
        self.head.brain.think()
    class Head:
        def __init__(self):
            self.brain=self.Brain()
        def talk(self):
            print("talking...")
        class Brain :
            def think(self):
                print("Thinking...")

Human("Neeraj").info()
class Person:
    def __init__(self, namee, dd,mm, yyyy) :
        self.name=namee
        self.dob=self.DOB(dd,mm,yyyy)
    def info(self):
        print("Name : ", self.name)
        self.dob.display()
    class DOB:
        def __init__(self,dd,mm,yyyy):
            self.dd=dd
            self.mm=mm
            self.yyyy=yyyy
        def display(self):
            print("Date of Birth : {} {}, {} ".format(self.mm,self.dd,self.yyyy))
p=Person("Neeraj Sharma",7,"Sept",1989 )
p.info()
            
<h3><center> Nested Methods</center></h3>
class Calc:
    def maths(self):
        def calc(a,b):
            print("Addition of {} and {} is {}".format(a,b,a+b))
            print("Subtraction of {} and {} is {}".format(a,b,a-b))
            print("Product of {} and {} is {}".format(a,b,a*b))
            print("Division of {} and {} is {}".format(a,b,a//b))
        calc(10,2)
        print("*"*20)
        calc(10,5)
c=Calc()
c.maths()

import time
class Demo:
    def __init__(self):
        print("Constructor Execution....")
    def __del__(self):
        print("Distructor Execution....")
l=[Demo(),Demo(),Demo()]
time.sleep(10)
print("end of application")
import time
class Demo2:
    def __init__(self):
        print("Constructor Execution....")
    def __del__(self):
        print("Distructor Execution....")
l=[Demo2(),Demo2(),Demo2()]
t=Demo2()
t=None
# time.sleep(3)
print("end of application")
<h3><center> HAS-A Relationship</center></h3>
By Has-A Relationship (Composition) <br> class Car has-a engine reference<br>code reuseability 
class Engine:
    def useEngine(self):
        print("Engine Specific Functionality...")

class Car:
    def __init__(self):
        self.engine=Engine()
    def useCar(self): 
        print("Car required Engine Functionality......")
        self.engine.useEngine()
Car().useCar()
class Car:
    def __init__(self,name,model,color):
        self.name=name
        self.model=model
        self.color=color
    def getInfo(self):
        return("Car Name: {}, Model : {}, Color : {}".format(self.name,self.model,self.color))
class Employee:
    def __init__(self,ename,eno,ecar):
        self.ename=ename
        self.eno=eno
        self.car=ecar
    def empInfo(self):
        print("Employee Name : ", self.ename)
        print("Employee Number : ", self.eno)
        print("Employee Car : ",self.car.getInfo())
        
car=Car("Ford","F150","Black")
emp=Employee("Neeraj",123456, car)
emp.empInfo()
class SportsNews:
    def __init__(self) -> None:
        pass
    def getInfo(self):
        print("Sports News")
class NationalNews:
    def __init__(self) -> None:
        pass
    def getInfo(self):
        print("National News")
class GlobalNews:
    def __init__(self) -> None:
        pass
    def getInfo(self):
        print("Internatioal News")

class AllNews:
    def __init__(self) -> None:
        self.sports=SportsNews()
        self.national=NationalNews()
        self.international=GlobalNews()
    def getAllNews(self):
        print("Today's Headlines")
        self.sports.getInfo()
        self.national.getInfo()
        self.international.getInfo()
        
AllNews().getAllNews()
class SportsNews:
    def __init__(self) -> None:
        pass
    def getInfo(self):
        print("Sports News")
class NationalNews:
    def __init__(self) -> None:
        pass
    def getInfo(self):
        print("National News")
class GlobalNews:
    def __init__(self) -> None:
        pass
    def getInfo(self):
        print("Internatioal News")

class AllNews:
    def __init__(self,sportsnews, nationalnews, globalnews  ) :
        self.sports=sportsnews
        self.national=nationalnews
        self.international=globalnews
    def getAllNews(self):
        print("Today's Headlines")
        self.sports.getInfo()
        self.national.getInfo()
        self.international.getInfo()
        
sports=SportsNews()
national=NationalNews()
international=GlobalNews()
allnews=AllNews(sports,national,international)
allnews.getAllNews()
<h3><center> IS-A Relationship</center></h3>
By Is-A Relationship (Inheritance)
class P:
    def m1(self):
        print("Parent Method")
class C(P):
    def m2 (self):
        print("Child Method")
c=C()
c.m1()
c.m2() 
<h4>Super Method</h4>
# super () Method
class Person():
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def display (self):
        print ('Name:', self.name)
        print ('Age:', self.age)
class Student(Person):
    def __init__(self, name, age, rollno, marks):
        super().__init__(name, age)
        self.rollno = rollno
        self.marks = marks
    def display(self):
        super().display()
        print('RollNo:', self.rollno)
        print ('Marks:', self.marks)
class Teacher(Person):
    def __init__(self, name, age, salary, subject):
        super().__init__(name, age)
        self.salary = salary
        self.subject = subject
    def display(self):
        super().display()
        print ('Salary:', self.salary)
        print ("Subject:", self.subject)
s=Student("Neer", 31, 7, 90)
t=Teacher("Santosh", 32, 200000, "Python and Java")
s.display()
t.display()
<h3><center> Composition and Agregation</center></h3>
composition--> strongly coupled , department is a part of university<br>
agregation --> weakly coupled, department has professor but professor is also an individual entity.  
class University:
    def __init__(self):
        self.department=self.Department()
    class Department():
        pass
u=University()
class Professor:
    pass
class Department:
    def __init__(self,professor):
        self.proferror=professor
prof=Professor()
dept1=Department(prof)
dept2=Department(prof)
<h4>practice questions for interview</h4>
inp=["abc","xyz","pqr"]
print(inp)
for aa in range(len(inp)):
    inp.append(inp[aa].upper())
print(inp)
Y = [2, 5J, 6]
Y.sort()
print(Y)
data=[1,2,3]
def incr(x):
    return x+1
print (list(map(incr,data)))
try:
    #do 
except:
    #do
finally:
    #do
inp=["abc","xyz","pqr"]
print("-".join(inp))
t='%(a)s %(b)s %(c)s'
print(t % dict(a="welcome",b="to", c="jungle"))
print("Neeraj sharma JI".capitalize())
z=set("abc")
z.add("sam")
z.update(set(['p','q']))
print(z)
class Hello:
    def __init__ (self, a="hello "):
        self.a=a
    def welcome(self,x):
        print(self.a+x)
Hello().welcome(" World")

class Developer (object):
    def __init__(self,skills):
        self.skills=skills
    def __add__(self,other):
        skills=self.skills + other.skills
        return Developer(skills)
    def __str__(self):
        return self.skills
A=Developer("Python")
B=Developer("Java")
print (A+B)
<h2>Method Resolution Order (MRO)</h2>
class A:pass
class B(A):pass
class C(A):pass
class D(C,B):pass
print (B.mro())
print (C.mro())
print (D.mro())
class A:pass
class B:pass
class C:pass
class D(A,B):pass
class E(B,C):pass 
class F(D,E,C):pass
print (F.mro())
DepthFirst Left to Right -DLR 
<br>
MRO(X)= X+merge(MRO(P1),MRO(P2),MRO(P3),....Parentlist)
C1C2C3C4-->C1 is Head and others are tail

# super () Method
class Person():
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def display (self):
        print ('Name:', self.name)
        print ('Age:', self.age)
class Student(Person):
    def __init__(self, name, age, rollno, marks):
        super().__init__(name, age)
        self.rollno = rollno
        self.marks = marks
    def display(self):
        super().display()
        print('RollNo:', self.rollno)
        print ('Marks:', self.marks)
class Teacher(Person):
    def __init__(self, name, age, salary, subject):
        super().__init__(name, age)
        self.salary = salary
        self.subject = subject
    def display(self):
        super().display()
        print ('Salary:', self.salary)
        print ("Subject:", self.subject)
s=Student("Neer", 31, 7, 90)
t=Teacher("Santosh", 32, 200000, "Python and Java")
s.display()
t.display()
class A:
    def m1(self):
        print("A Class Methos")
class B(A):
    def m1(self):
        print("B Class Methos")
class C(B):
    def m1(self):
        print("C Class Methos")
class D(C):
    def m1(self):
        print("D Class Methos")
        super().m1()
        B.m1(self)
        super(B,self).m1()
obj=D()
obj.m1()
class A:
    def m1(self):
        print("A Class Methos")
class B(A):
    def m1(self):
        print("B Class Methos")
class C(B):
    def m1(self):
        print("C Class Methos")
class D(C):
    def m1(self):
        super(C,self).m1()
         
obj=D()
obj.m1()
class  A:
    a=100
    def __init__(self):
        self.b=222
class B(A):
    a=111
    def __init__(self):
        self.b=333
    def m1(self):
       print(B.a)
       print(A.a)
       print(super().a)
       print(A.a+self.b)
b=B()
b.m1()
<h2><center>POLYMORPHISM</center></h2>
<h3> OVERLOADING</h3>
1. operator overloading<br>
2. method overloading <br>
3. constructor overloading<br>
<h3>OVERRIDING</h3>
1. method overriding<br>
2. constructor overriding
<h2><center>__add__</center></h2>
class Book:
    def __init__(self,pages):
        self.pages=pages
    def __add__(self,other):
        total_pages=self.pages+other.pages
        return total_pages
b1=Book(100)
b2=Book(200)
b3=Book(300)
print(b1+b2)
print(b1+b2+b3)
<h2><center>__gt__</center></h2>
class Student:
    def __init__(self,name,marks):
        self.name=name
        self.marks=marks
    def __gt__(self,other):
        return self.marks>other.marks
s1=Student("Neeraj", 100)
s2=Student("Dimpi", 200)
print(s1>s2)
<h2><center>__str__</center></h2>
class Student:
    def __init__(self,name,roll,marks):
        self.name=name
        self.roll=roll
        self.marks=marks
    def __str__(self):
        return("Name : {}, Roll No. : {}, Marks : {}".format(self.name,self.roll,self.marks))
s1=Student("Neeraj",101,99)
s2=Student("Santosh",102,100)
print(s1)
print(s2)
class Book:
    def __init__(self,pages):
        self.pages=pages
    def __add__(self,other):
        return Book(self.pages+other.pages)
    def __str__(self):
        return ("Total No of pages is {}".format (self.pages))
b1=Book(100)
b2=Book(200)
b3=Book(300)
print(b1+b2+b3)
